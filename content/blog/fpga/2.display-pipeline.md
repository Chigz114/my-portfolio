---
title: "The Display Pipeline"
date: "2025-11-24"
description: "A detailed walkthrough of configuring MIG, VDMA, VTC, and Video Out to build a complete video output pipeline on FPGA."
tags: ["FPGA", "3D Renderer", "Vivado", "AXI", "Video"]
---

## Overview

Before you can render anything on screen, you need a working video pipeline. This is the foundation of the entire TinyGPU project -- without it, you're just pushing pixels into the void.

The goal is simple: take pixel data from DDR3 memory and display it on a 640×480 @ 60Hz VGA monitor. But achieving this requires careful configuration of multiple Xilinx IP cores and understanding how data flows between them.

### The Data Flow

```
DDR3 (Framebuffer)
      ↓
MIG (Memory Controller)
      ↓
AXI Interconnect
      ↓
AXI VDMA (MM2S)
      ↓
AXI4-Stream Video
      ↓
Video Out (vid_io_out)
      ↓
VGA Signals
```

Let's break down each component.



## MIG: The Memory Controller

The MIG (Memory Interface Generator) is the bridge between your FPGA logic and the DDR3 chip. Without it, you cannot access the framebuffer.

### Key Configuration

![image-20251124230502357](https://s2.loli.net/2025/11/25/JaWcujGKrl721Mx.png)

![image-20251124230524358](https://s2.loli.net/2025/11/25/ZOWUijQe1mHzukp.png)

![image-20251124230545401](https://s2.loli.net/2025/11/25/QqmuMbJHjzw4od6.png)

![image-20251124230601269](https://s2.loli.net/2025/11/25/BfbdzmYy4lCcZQw.png)

### Clock Architecture

MIG generates its own clocks internally:
- **UI Clock**: 83.33 MHz -- this is the main AXI clock domain
- All AXI masters/slaves connected to MIG must operate in this clock domain




## AXI VDMA: The Video DMA Engine

VDMA is the heart of the video pipeline. It handles high-bandwidth memory transfers between DDR3 and the video stream.

### Two Channels

VDMA has two independent channels:

- **MM2S (Memory-Mapped to Stream)**: Reads from DDR3, outputs AXI4-Stream. This is what drives the display.
- **S2MM (Stream to Memory-Mapped)**: Receives AXI4-Stream, writes to DDR3. This is what your renderer uses to write pixels.

For the display pipeline, we focus on **MM2S**.

### Key Configuration

![image-20251124230721260](https://s2.loli.net/2025/11/25/fgK9aI582SrsEmM.png)

![image-20251124230736543](https://s2.loli.net/2025/11/25/pxvBG2N4XiTQkmE.png)



### Register Setup (C Code from MicroBlaze)

```c
// Base address of VDMA
#define VDMA_BASE 0x43000000

// MM2S Control Register - Run, Circular Mode, GenLock Master
Xil_Out32(VDMA_BASE + 0x00, 0x8B);

// Start Address (Frame 0)
Xil_Out32(VDMA_BASE + 0x5C, 0x80000000);

// Horizontal Size (bytes per line) - 640 pixels × 4 bytes (RGBD)
Xil_Out32(VDMA_BASE + 0x54, 640 * 4);

// Vertical Size (number of lines) - This starts the transfer!
Xil_Out32(VDMA_BASE + 0x50, 480);
```

Note: Its just a sample, you need to modify the address on your own.

### GenLock Synchronization

GenLock is critical for preventing tearing artifacts when you have both a producer (renderer) and consumer (display) accessing the framebuffer. VDMA provides several synchronization modes:

**Fsync Options (Frame Sync):**
- **None**: No external frame sync. The channel runs freely.
- **s2mm fsync / mm2s fsync**: Synchronize to an external fsync signal.
- **s2mm tuser / mm2s tuser**: Use the `tuser` signal in AXI-Stream as frame boundary indicator. This is common for video streams where `tuser=1` marks the first pixel of a new frame.

**GenLock Modes:**
- **Master**: This channel dictates the frame buffer switching. Other channels follow.
- **Slave**: Strictly follows the Master's buffer selection.
- **Dynamic-Master**: Like Master, but can dynamically skip frames if the slave falls behind.
- **Dynamic-Slave**: Follows the Master, but can skip to catch up if it falls behind.

**Our Configuration:**
- **Read Channel (MM2S)**: GenLock Master, Fsync = None
- **Write Channel (S2MM)**: Dynamic-Slave, Fsync = s2mm tuser

**Why this setup?**

The display (MM2S) must run at a constant 60Hz -- it cannot skip or stutter. So we make it the **Master**. The renderer (S2MM) writes frames as fast as it can, using `tuser` to signal frame boundaries. As a **Dynamic-Slave**, if the renderer is slower than 60fps, the display simply shows the last complete frame again. If the renderer is faster, it waits for the display to release a buffer.

This ensures:
- The display always reads from a complete frame
- The renderer writes to a different buffer than the one being displayed
- No tearing artifacts
- Graceful handling of frame rate mismatches

## VTC: Video Timing Controller

VTC generates the timing signals that define your video format. It tells the display when each line and frame begins/ends.

### The Role of VTC in the Pipeline

VTC is the **conductor** of the entire video output pipeline. It doesn't carry any pixel data -- instead, it produces timing signals that tell other modules *when* to act:

- **Video Out** listens to VTC's `vtiming_out` to know when to pull pixels from its FIFO and when to assert hsync/vsync.
- **VDMA** (when using fsync) can synchronize its frame reads to VTC's frame boundaries.
- The **display monitor** locks onto the hsync/vsync signals to correctly position the image.

Without VTC, Video Out wouldn't know when a line ends or when a new frame begins. The result would be a garbled or rolling image.

### 640×480 @ 60Hz Timing (480p Mode)

![image-20251124231059341](https://s2.loli.net/2025/11/25/i5mkKIlUvnBxQeo.png)

### VTC Configuration Notes

![image-20251124231143163](https://s2.loli.net/2025/11/25/CfFZaPAGueSULVt.png)

### Pixel Clock

For 640×480 @ 60Hz:
```
Pixel Clock = 800 × 525 × 60 = 25.2 MHz
```

You need to generate a ~25 MHz clock using a Clocking Wizard (MMCM/PLL). This clock drives VTC and Video Out.



## Video Out: The Final Stage

Video Out (AXI4-Stream to Video Out) converts the AXI4-Stream from VDMA into parallel video signals suitable for VGA/HDMI.

### Key Configuration

![image-20251124234733835](https://s2.loli.net/2025/11/25/G72rH8thQYPdLSy.png)

### Why RGBD Format?

The stream uses 32-bit data width (RGBD) instead of 24-bit (RGB888). This design choice balances several considerations:

1. **High Color Depth**: RGB888 provides 16.7 million colors (8 bits per channel), which is sufficient for high-quality graphics.

2. **AXI Alignment**: 32-bit data width aligns perfectly with common AXI bus widths (32, 64, 128...). Using 24-bit would require awkward packing/unpacking logic and triggers Vivado's resource overhead warning for non-power-of-2 widths.

3. **Future Extensibility**: The 4th byte (D) can be repurposed as an **Alpha channel** for transparency effects, enabling features like blending and compositing in future iterations.



## Step-by-Step Bring-Up Guide

Building the display pipeline is not a one-shot process. Here's a recommended incremental approach, with common issues and debugging strategies at each stage.

### Stage 1: MIG + MicroBlaze Basic Test

**Goal**: Verify DDR3 read/write works correctly.

**Setup**:
- Connect MicroBlaze directly to MIG via AXI Interconnect.
- Write a simple C program to write data to DDR3 and read it back.

```c
// Simple memory test
uint32_t *mem = (uint32_t *)0x80000000;
mem[0] = 0xDEADBEEF;
if (mem[0] == 0xDEADBEEF) {
    xil_printf("DDR3 OK!\n");
} else {
    xil_printf("DDR3 FAIL!\n");
}
```

**Common Issues**:
- **Read returns garbage**: Check your address map in Vivado's Address Editor. Ensure MIG is assigned the correct address range (e.g., `0x80000000`).
- **System hangs on memory access**: MIG calibration may have failed. Check `init_calib_complete` signal. Also verify your MIG clock and reset connections.
- **Intermittent failures**: Could be timing issues. Ensure all AXI masters/slaves are in the same clock domain (`ui_clk`).

Note: If you follow the ECE 385's instruction of MIG setting, you may have used 0x80000000 to store instructions of MicroBlaze, then you should store your frame data from 0x81000000 to avoid overwriting.

### Stage 2: Build the Output Path (DDR → Display)

**Goal**: Display data written by MicroBlaze on the screen.

**Setup**:
1. Add VDMA, VTC, and Video Out to the block design.
2. Connect VDMA's MM2S channel to read from DDR3.
3. Connect Video Out's `vid_io_out` to a simple **VGA-to-HDMI** module at the top level. (This module is straightforward -- just directly wiring VGA signals to HDMI TMDS encoder -- so we won't cover it in detail.)
4. Use MicroBlaze to fill the framebuffer with a test pattern (e.g., solid color or gradient), then configure VDMA to start reading.

**Common Issues**:

**Black Screen (No Signal)**:
- **No data flow**: VDMA might not be running. Read the status register (`0x04` for MM2S) to check for errors.
- **Clock domain mismatch**: The pipeline has two clock domains:
  - **83.33 MHz (ui_clk)**: MIG, AXI Interconnect, VDMA's AXI side
  - **25 MHz (video_clk)**: VTC, Video Out, VDMA's stream side
  
  Ensure each module is connected to the correct clock. VDMA handles the crossing internally.
- **Data width mismatch**: If VDMA outputs 32-bit but Video Out expects 24-bit, you'll get nothing. Ensure both are configured for the same format (RGBD/32-bit in our case).

**Debugging via Software**:
```c
// Read VDMA MM2S status register
uint32_t status = Xil_In32(VDMA_BASE + 0x04);
xil_printf("MM2S Status: 0x%08X\n", status);
// Check for errors: bit 4 = DMAIntErr, bit 5 = DMASlvErr, bit 6 = DMADecErr
```

**Debugging via Hardware**:
- Connect board LEDs to key signals:
  - `init_calib_complete` (MIG ready)
  - `mm2s_fsync` (frame sync)
  - `s_axis_s2mm_tready` / `m_axis_mm2s_tvalid` (data flow indicators)
  - `underflow` / `overflow` flags from Video Out

**Colored Vertical Stripes**:
- This classic symptom indicates a **data width mismatch**. If you accidentally inserted an AXI4-Stream Data Width Converter that converts 32-bit to 24-bit, the RGB channels get misaligned. Each pixel "borrows" bits from the next, creating rainbow stripes.
- **Solution**: Remove the converter. Use 32-bit (RGBD) throughout the pipeline.

**Image Shifted or Wrapped**:
- **Stride misconfiguration**: If your horizontal size is 640×4=2560 bytes but stride is set to 2048, each line will be truncated and the next line starts at the wrong offset.
- **Solution**: Ensure `Stride >= Horizontal Size`, and both are correctly set in VDMA registers.

**Software Configuration Pitfalls**:
- **Forgot to start VDMA**: Writing to the Vertical Size register triggers the transfer. If you set Horizontal Size *after* Vertical Size, the first frame uses wrong parameters.
- **Wrong frame buffer address**: If you point VDMA to an address outside DDR3 range, it will hang or read garbage.
- **Registers not taking effect**: Some VDMA registers are double-buffered. Changes may not apply until the next frame. Check the `FRMSTORE` register.

### Stage 3: Build the Input Path (Renderer → DDR)

**Goal**: Write pixel data from a custom module (your renderer) into DDR3 via VDMA's S2MM channel.

**Setup**:
1. Disconnect MicroBlaze's direct DDR3 access for framebuffer writes (it can still be used for control).
2. Create a test module that generates a simple pattern (e.g., color bars) and outputs it as an AXI4-Stream.
3. Connect this module to VDMA's S2MM channel.

**Note on Vivado 2022.2**: The Block Design's "Add Module" feature doesn't directly support SystemVerilog (`.sv`) files. You need to wrap your SV module in a Verilog (`.v`) wrapper.

**Clock Domain Considerations**:

VDMA's S2MM input typically runs at **83.33 MHz** (ui_clk domain), while the output (MM2S) runs at **25 MHz** (video_clk domain). VDMA handles this crossing internally.

However, if your renderer has timing issues (negative WNS) at 83.33 MHz, you might want to run it at **25 MHz** instead. This sacrifices some frame rate headroom but makes timing closure easier.

**If your renderer runs at a different clock than VDMA's S2MM expects**, you need to insert an **AXI4-Stream FIFO** (with independent clocks enabled) between them:

```
Renderer (25 MHz) → AXI4-Stream FIFO → VDMA S2MM (83.33 MHz)
```

**Common Issues**:

**Black Screen (Output path was working!)**:
- Since the output path is already verified, the problem is likely in the input path.
- **AXI-Stream protocol violation**: Check your `tuser`, `tlast`, and `tvalid` signals.
  - `tuser` must be HIGH for exactly one clock cycle at the **first pixel of each frame**.
  - `tlast` must be HIGH at the **last pixel of each line**.
  - `tvalid` must only be HIGH when you have valid data to send.
- **Verify data is actually written to DDR**: Use MicroBlaze to read back the framebuffer region:

```c
// Check if renderer wrote anything
uint32_t *fb = (uint32_t *)0x80000000;
xil_printf("FB[0] = 0x%08X\n", fb[0]);
xil_printf("FB[1] = 0x%08X\n", fb[1]);
// If these are still 0 or unchanged, S2MM isn't writing.
```

**Data Written but Display Shows Old Content**:
- GenLock buffer switching might not be working. Check that S2MM is configured as Dynamic-Slave and MM2S as Master.
- Verify `tuser` is correctly generated -- it triggers the frame boundary detection.

**Partial Frame or Corrupted Image**:
- Line length mismatch: Ensure your renderer outputs exactly 640 pixels per line with `tlast` on the 640th pixel.
- Frame length mismatch: Ensure exactly 480 lines per frame with `tuser` on the first pixel of line 0.

**VDMA S2MM Errors**:
```c
uint32_t s2mm_status = Xil_In32(VDMA_BASE + 0x34);
xil_printf("S2MM Status: 0x%08X\n", s2mm_status);
// Bit 4: DMAIntErr (internal error)
// Bit 5: DMASlvErr (slave error from interconnect)
// Bit 6: DMADecErr (decode error - bad address)
```

### Stage 4: Integration and Optimization

Once both paths work independently, you can connect your actual renderer and start optimizing.

![renderer](/images/blog/fpga/renderer.svg)




## Summary

The display pipeline is the first major milestone in building TinyGPU. Once you see a stable image on screen, you know the foundation is solid. With this pipeline working, you're ready to start writing actual pixels from your renderer.
