---
title: "5. PWM Motor Speed Control"
date: "2025-02-06"
description: "Controlling DC motor speed using PWM signals generated by STM32 timer."
tags: ["STM32", "PWM", "Motor Control", "Timer"]
---

## PWM Motor Speed Control

To control motor speed in a digital system, we use **Pulse Width Modulation (PWM)**. Instead of varying voltage directly (which would require a DAC), we rapidly switch between HIGH and LOW states. The motor's inertia averages this into an effective voltage proportional to the duty cycle.

### PWM Fundamentals

$$
V_{effective} = V_{supply} \times \frac{t_{on}}{t_{on} + t_{off}} = V_{supply} \times \text{Duty Cycle}
$$

- **100% duty cycle**: Full speed
- **50% duty cycle**: Half speed
- **0% duty cycle**: Motor stopped

### Hardware Configuration

The S28A board uses TIM1 for PWM output:

| Signal | Pin | Timer Channel |
|--------|-----|---------------|
| Motor A PWM | PA8 | TIM1_CH1 |
| Motor B PWM | PA11 | TIM1_CH4 |

Direction control uses separate GPIO pins (check your board schematic).

### TIM1 PWM Configuration

```c
void PWM_Init(void) {
    // Enable clocks
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    // Configure GPIO as alternate function push-pull
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_11;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    
    // Timer base: 72MHz / 72 / 1000 = 1kHz PWM frequency
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    TIM_TimeBaseStructure.TIM_Prescaler = 72 - 1;
    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseStructure.TIM_Period = 1000 - 1;  // 0-999 duty range
    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
    
    // PWM mode configuration
    TIM_OCInitTypeDef TIM_OCInitStructure;
    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
    TIM_OCInitStructure.TIM_Pulse = 0;  // Initial duty = 0
    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
    
    TIM_OC1Init(TIM1, &TIM_OCInitStructure);  // Channel 1
    TIM_OC4Init(TIM1, &TIM_OCInitStructure);  // Channel 4
    
    // Enable preload
    TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
    TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);
    
    // TIM1 requires main output enable
    TIM_CtrlPWMOutputs(TIM1, ENABLE);
    TIM_Cmd(TIM1, ENABLE);
}
```

### Setting Motor Speed

```c
void Set_Motor_Speed(int16_t left, int16_t right) {
    // Clamp values to valid range
    if (left > 1000) left = 1000;
    if (left < -1000) left = -1000;
    if (right > 1000) right = 1000;
    if (right < -1000) right = -1000;
    
    // Left motor
    if (left >= 0) {
        LEFT_DIR_FORWARD();
        TIM_SetCompare1(TIM1, left);
    } else {
        LEFT_DIR_BACKWARD();
        TIM_SetCompare1(TIM1, -left);
    }
    
    // Right motor
    if (right >= 0) {
        RIGHT_DIR_FORWARD();
        TIM_SetCompare4(TIM1, right);
    } else {
        RIGHT_DIR_BACKWARD();
        TIM_SetCompare4(TIM1, -right);
    }
}
```

### PWM Frequency Selection

| Frequency | Characteristics |
|-----------|-----------------|
| < 1kHz | Audible whine |
| 1-20kHz | Good for most DC motors |
| > 20kHz | Inaudible, but may cause heating |

1kHz is a reasonable starting point for small DC motors.

### Testing

Apply a fixed duty cycle and verify motor rotation:

```c
Set_Motor_Speed(500, 500);  // 50% speed forward
Delay_ms(2000);
Set_Motor_Speed(-500, -500); // 50% speed backward
Delay_ms(2000);
Set_Motor_Speed(0, 0);       // Stop
```

> **Caution**: Always implement software limits to prevent runaway motors during development.
