---
title: "1. OLED Display Driver via Software I2C"
date: "2024-11-22"
description: "Porting a 4-pin I2C OLED driver to the self-balancing robot platform with GPIO remapping."
tags: ["STM32", "I2C", "OLED", "Embedded"]
---

## OLED Display Driver

An OLED display is essential for debugging embedded systems—it provides real-time feedback on sensor values, system state, and error messages without requiring a debugger connection.

### Objective

Port a software I2C OLED driver to the robot's hardware configuration. The robot uses **PB4** (SDA) and **PB5** (SCL) for I2C communication.

### Background: Software vs Hardware I2C

The STM32F103 has dedicated hardware I2C peripherals on specific pins. However, PB4 and PB5 are not standard I2C pins, so we use **software (bit-banged) I2C** instead. This approach:

- Works on any GPIO pins
- Is simpler to port between projects
- Has slightly lower performance (acceptable for displays)

### Challenge: JTAG Pin Conflict

**PB4 is shared with JTAG (NJTRST)**. After reset, PB4 defaults to JTAG function and cannot be used as GPIO unless explicitly remapped.




### Solution

Add the following code to your `OLED_I2C_Init()` function to disable JTAG while keeping SWD for debugging:

```c
// Enable AFIO clock (required for pin remapping)
RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);

// Disable JTAG, keep SWD (frees PB3, PB4, PA15)
GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);
```

### Pin Configuration

Update the GPIO pin definitions in your I2C driver:

| Signal | Original Pin | New Pin |
|--------|--------------|---------|
| SCL | PB8 | PB5 |
| SDA | PB9 | PB4 |

### Verification

After configuration, test the display by showing a simple message or counter. If the screen remains blank:

1. Check power connections (VCC, GND)
2. Verify I2C address (typically `0x78` for SSD1306)
3. Confirm the JTAG disable code runs before GPIO init
4. Use an oscilloscope to verify SCL/SDA signals

---

*Next: [2. MPU6050 IMU Integration →](./2.mpu6050-integration)*
