---
title: "7. PID Control for Balance"
date: "2025-02-06"
description: "Implementing PID controllers for self-balancing robot stabilization and velocity control."
tags: ["STM32", "PID", "Control Theory", "Robotics"]
---

## PID Control for Balance

With all sensors and actuators configured, the final step is implementing the **control algorithm** that keeps the robot balanced. We'll use **PID control**—a fundamental feedback control technique.

### The Balance Problem

Given:
- Current tilt angle θ (from Kalman filter)
- Current angular velocity ω (from gyroscope)
- Current wheel speed (from encoders)

Find:
- Motor PWM duty cycle that returns the robot to upright position

### Proportional Control (P)

The simplest approach: motor output proportional to error.

$$
PWM = K_p \times \theta
$$

If tilted 10° forward, apply proportional forward motor power to accelerate and catch up.

**Problem**: Like a spring without damping, this causes oscillation. The robot overshoots, tilts backward, overshoots again, and may never stabilize.

### Adding Derivative Control (D)

To prevent overshoot, we add a term proportional to the **rate of change** of the error:

$$
PWM = K_p \times \theta - K_d \times \omega
$$

The derivative term acts like a damper:
- When falling fast → large ω → reduces motor output
- When recovering → ω opposes motion → smooths response

> **Note**: The negative sign is because we want to oppose rapid changes. Verify the sign matches your gyroscope orientation.

### PD Balance Controller

```c
int16_t Balance_PD(float angle, float gyro) {
    float Kp = 32.0f;   // Proportional gain
    float Kd = 0.16f;   // Derivative gain
    
    int16_t pwm = (int16_t)(Kp * angle + Kd * gyro);
    
    // Output limiting
    if (pwm > 1000) pwm = 1000;
    if (pwm < -1000) pwm = -1000;
    
    return pwm;
}
```

### Velocity Control with PI

The PD controller keeps the robot upright but doesn't control position—it will drift. Adding a **velocity loop** with PI control addresses this:

$$
PWM_{velocity} = K_{vp} \times (v_{target} - v_{actual}) + K_{vi} \times \int error \, dt
$$

The integral term accumulates small errors over time, eventually providing enough correction to reach the target velocity (usually zero for stationary balance).

```c
int16_t Velocity_PI(int16_t left_encoder, int16_t right_encoder) {
    static float integral = 0;
    static float last_error = 0;
    
    float Kp = 2.45f;
    float Ki = 0.015f;
    
    // Current velocity (encoder counts per period)
    float velocity = (float)(left_encoder + right_encoder);
    
    // Error (target is 0 for stationary)
    float error = 0 - velocity;
    
    // Low-pass filter on error (reduces noise)
    error = last_error * 0.7f + error * 0.3f;
    last_error = error;
    
    // Integral with anti-windup
    integral += error;
    if (integral > 1500) integral = 1500;
    if (integral < -1500) integral = -1500;
    
    return (int16_t)(Kp * error + Ki * integral);
}
```

### Combined Control

```c
void Control_Loop(void) {
    // Balance PD
    int16_t pwm_balance = Balance_PD(pitch_angle, gyro_x);
    
    // Velocity PI
    int16_t pwm_velocity = Velocity_PI(left_encoder, right_encoder);
    
    // Combined output
    int16_t pwm = pwm_balance + pwm_velocity;
    
    // Apply to motors
    Set_Motor_Speed(pwm, pwm);
}
```

### Tuning Guidelines

**Start with balance loop only** (set velocity gains to 0):

1. Increase Kp until robot starts oscillating
2. Add Kd to dampen oscillation
3. Fine-tune until stable

**Then add velocity loop**:

1. Start with very small Ki (0.01)
2. Increase Kp until drift is controlled
3. Increase Ki slowly to eliminate steady-state error

### Reference Parameters

For 50Hz control loop (tested values):

| Parameter | Value | Notes |
|-----------|-------|-------|
| Balance Kp | 32.0 | Main balance response |
| Balance Kd | 0.16 | Damping |
| Velocity Kp | 2.45 | Position holding |
| Velocity Ki | 0.015 | Drift elimination |

These are starting points—your robot may need different values based on weight distribution, motor characteristics, and sensor mounting.

### Troubleshooting

| Symptom | Likely Cause | Solution |
|---------|--------------|----------|
| Oscillates rapidly | Kp too high | Reduce Kp |
| Falls over slowly | Kp too low | Increase Kp |
| Overshoots then recovers | Kd too low | Increase Kd |
| Vibrates/jitters | Kd too high | Reduce Kd |
| Drifts in one direction | Sensor bias or Ki too low | Calibrate or increase Ki |
| Runs away | Wrong sign on gains | Check gyro/motor polarity |

### Low-Pass Filter Explanation

The velocity error filter in the code:

```c
error = last_error * 0.7f + error * 0.3f;
```

This is a simple **exponential moving average** that smooths noisy encoder readings. The coefficients (0.7, 0.3) determine the cutoff frequency—higher first coefficient = more smoothing.
