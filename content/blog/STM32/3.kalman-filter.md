---
title: "3. Kalman Filter for Sensor Fusion"
date: "2025-01-20"
description: "Implementing a Kalman filter to fuse accelerometer and gyroscope data for accurate attitude estimation."
tags: ["STM32", "Kalman Filter", "Sensor Fusion", "Control Theory"]
---

## Kalman Filter for Sensor Fusion

In MP2, we observed that raw MPU6050 readings have two major issues:

1. **Bias offset**: Non-zero readings when stationary
2. **High-frequency noise**: Rapid fluctuations between samples

This tutorial addresses both problems using a **Kalman filter**—an optimal recursive algorithm for estimating system state from noisy measurements.

### Problem 1: Bias Calibration

The solution is straightforward: sample the sensor while stationary and compute the average offset, then subtract it from all future readings.

```c
// Calibration: average N samples while stationary
for (int i = 0; i < N; i++) {
    gyro_bias_x += raw_gyro_x;
}
gyro_bias_x /= N;

// Runtime: subtract bias
float gyro_x = raw_gyro_x - gyro_bias_x;
```

### Problem 2: Sensor Fusion with Kalman Filter

We have two ways to estimate the robot's tilt angle:

| Method | Source | Characteristics |
|--------|--------|-----------------|
| Integration | Gyroscope | Accurate short-term, drifts over time |
| Trigonometry | Accelerometer | Noisy but no drift |

The Kalman filter optimally combines both by weighting them based on their respective uncertainties.

### The Five Kalman Filter Equations

#### 1. State Prediction

$$
\hat{x}_k^- = A\hat{x}_{k-1} + Bu_k
$$

- $\hat{x}_k^-$: Prior state estimate (angle, gyro bias)
- $A$: State transition matrix
- $B$: Control input matrix
- $u_k$: Control input (gyroscope reading)

For our balance robot:

$$
A = \begin{pmatrix} 1 & 0 \\ 0 & 0 \end{pmatrix}, \quad
B = \begin{pmatrix} \Delta t \\ 0 \end{pmatrix}
$$

The predicted angle = previous angle + (angular velocity × time step).

#### 2. Covariance Prediction

$$
P_k^- = AP_{k-1}A^T + Q
$$

- $P_k^-$: Prior error covariance
- $Q$: Process noise covariance (tuning parameter)

This propagates our uncertainty forward in time.

#### 3. Kalman Gain

$$
K_k = P_k^- H^T (HP_k^- H^T + R)^{-1}
$$

- $K_k$: Kalman gain (how much to trust the measurement)
- $H$: Observation matrix
- $R$: Measurement noise covariance

When $R \to \infty$: Trust prediction (ignore noisy measurement)
When $R \to 0$: Trust measurement (ignore prediction)

#### 4. State Update

$$
\hat{x}_k = \hat{x}_k^- + K_k(z_k - H\hat{x}_k^-)
$$

- $z_k$: Actual measurement (angle from accelerometer)
- $(z_k - H\hat{x}_k^-)$: Innovation (measurement residual)

#### 5. Covariance Update

$$
P_k = (I - K_k H)P_k^-
$$

Updates our confidence in the estimate for the next iteration.

### Implementation for Balance Robot

For pitch angle estimation:

```c
// State vector: [angle, gyro_bias]
// Measurement: angle from accelerometer

// Tuning parameters (start with these)
float Q_angle = 0.001f;    // Process noise for angle
float Q_bias = 0.003f;     // Process noise for gyro bias
float R_measure = 0.03f;   // Measurement noise

float angle = 0.0f;        // Estimated angle
float bias = 0.0f;         // Estimated gyro bias
float P[2][2] = {{0, 0}, {0, 0}};  // Error covariance

float Kalman_GetAngle(float newAngle, float newRate, float dt) {
    // Step 1: Predict
    angle += dt * (newRate - bias);
    
    P[0][0] += dt * (dt * P[1][1] - P[0][1] - P[1][0] + Q_angle);
    P[0][1] -= dt * P[1][1];
    P[1][0] -= dt * P[1][1];
    P[1][1] += Q_bias * dt;
    
    // Step 2: Update
    float S = P[0][0] + R_measure;
    float K[2] = {P[0][0] / S, P[1][0] / S};
    
    float y = newAngle - angle;  // Innovation
    angle += K[0] * y;
    bias += K[1] * y;
    
    float P00_temp = P[0][0];
    float P01_temp = P[0][1];
    P[0][0] -= K[0] * P00_temp;
    P[0][1] -= K[0] * P01_temp;
    P[1][0] -= K[1] * P00_temp;
    P[1][1] -= K[1] * P01_temp;
    
    return angle;
}
```

### Computing Angle from Accelerometer

Use `atan2()` to compute the tilt angle from gravity components:

```c
#include <math.h>

// For pitch (rotation around X-axis)
float accel_angle = atan2(accel_y, accel_z) * 180.0f / M_PI;
```

To use `atan2()` on STM32:
1. Add `ARM_MATH_CM3` to compiler defines
2. Include `arm_math.h`
3. Link the math library

### Tuning Guidelines

| Parameter | Effect of Increasing |
|-----------|---------------------|
| Q_angle | Trust gyro less, respond faster to accel |
| Q_bias | Allow bias to change faster |
| R_measure | Trust accelerometer less, smoother output |

Start with the provided values and adjust based on observed behavior:
- **Oscillation**: Increase R_measure
- **Slow response**: Decrease R_measure or increase Q_angle
- **Drift**: Decrease Q_bias

### Limitations

The Kalman filter works well for **pitch** and **roll** (where gravity provides a reference). However, **yaw** (rotation around the vertical axis) cannot be estimated from a 6-axis IMU alone—you would need a magnetometer or other heading reference.

---

*Next: [4. Motor Encoder Configuration →](./4.motor-encoder)*
