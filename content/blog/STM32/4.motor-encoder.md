---
title: "4. Motor Encoder Configuration"
date: "2025-01-21"
description: "Configuring STM32 timer encoder interface to read motor speed from quadrature encoders."
tags: ["STM32", "Encoder", "Timer", "Motor Control"]
---

## Motor Encoder Configuration

After obtaining the filtered tilt angle from the Kalman filter, we need to control motor speed to maintain balance. But first, we must be able to **measure** motor speed—this is where encoders come in.

### How Quadrature Encoders Work

Magnetic encoders on DC motors produce two square wave signals (A and B) that are 90° out of phase. The STM32's timer peripheral has a built-in **encoder interface** that:

1. Counts pulses automatically
2. Determines rotation direction from phase relationship
3. Handles edge detection in hardware

### Hardware Configuration

From the S28A board pinout:

| Motor | Encoder A | Encoder B | Timer |
|-------|-----------|-----------|-------|
| Left  | PA6       | PA7       | TIM3  |
| Right | PB6       | PB7       | TIM4  |

### Timer Encoder Interface Setup

```c
void Encoder_Init_TIM3(void) {
    // Enable clocks
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    // Configure GPIO as input
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    
    // Timer base configuration
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    TIM_TimeBaseStructure.TIM_Prescaler = 0;           // No prescaling
    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseStructure.TIM_Period = 65535;          // Max count (16-bit)
    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
    
    // Encoder interface configuration
    TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12,
                               TIM_ICPolarity_Rising,
                               TIM_ICPolarity_Rising);
    
    // Clear counter and enable
    TIM_SetCounter(TIM3, 0);
    TIM_Cmd(TIM3, ENABLE);
}
```

Repeat similarly for TIM4 with PB6/PB7.

### Reading Encoder Values

```c
int16_t Read_Encoder(uint8_t timer) {
    int16_t value = 0;
    
    switch (timer) {
        case 3:
            value = (int16_t)TIM_GetCounter(TIM3);
            TIM_SetCounter(TIM3, 0);  // Reset for next reading
            break;
        case 4:
            value = (int16_t)TIM_GetCounter(TIM4);
            TIM_SetCounter(TIM4, 0);
            break;
    }
    
    return value;
}
```

### Converting to Speed

The encoder count represents **pulses per sampling period**. To get actual speed:

$$
\text{Speed (RPM)} = \frac{\text{Count} \times 60}{\text{PPR} \times \text{Sample Period (s)}}
$$

Where PPR = Pulses Per Revolution (check motor datasheet).

### Testing

You don't need motor control code to test encoders—simply rotate the wheels by hand and observe the count on OLED:

```c
while (1) {
    int16_t left = Read_Encoder(3);
    int16_t right = Read_Encoder(4);
    
    OLED_ShowSignedNum(1, 1, left, 5);
    OLED_ShowSignedNum(2, 1, right, 5);
    
    Delay_ms(100);
}
```

- Positive values: Forward rotation
- Negative values: Backward rotation

### Notes

1. **No prescaler needed**: We want maximum resolution, so count every edge.

2. **16-bit overflow**: The counter wraps at 65535. Read frequently enough (e.g., 50Hz) to avoid overflow during normal operation.

3. **Interrupt handling**: The vendor code includes overflow interrupt handlers, but these are rarely triggered with proper sampling rates.
