---
title: "2. MPU6050 IMU Integration"
date: "2025-01-15"
description: "Integrating the MPU6050 6-axis IMU with STM32 for attitude sensing in a self-balancing robot."
tags: ["STM32", "MPU6050", "IMU", "I2C", "Sensors", "Robotics"]
---

## MPU6050 IMU Integration

The MPU6050 is the core sensor for our self-balancing robot. It's a 6-axis Inertial Measurement Unit (IMU) containing:

- **3-axis accelerometer**: Measures linear acceleration (including gravity)
- **3-axis gyroscope**: Measures angular velocity

### Why Both Sensors?

Neither sensor alone provides reliable attitude estimation:

| Sensor | Strength | Weakness |
|--------|----------|----------|
| Accelerometer | Accurate at rest (measures gravity direction) | Noisy during motion; affected by linear acceleration |
| Gyroscope | Accurate during rotation; immune to linear motion | Accumulates drift over time (integration error) |

By fusing both sensors (covered in MP3), we get the best of both worlds.

### Objectives

1. Read raw accelerometer and gyroscope data from MPU6050
2. Convert raw values to physical units (m/s², rad/s)
3. Display readings on OLED at 50Hz
4. Set up TIM2 timer interrupt for periodic sampling

### Step 1: Timer Interrupt Setup

Configure TIM2 for 50Hz interrupts. With a 72MHz system clock:

```
Interrupt Frequency = 72MHz / (PSC + 1) / (ARR + 1)
50Hz = 72MHz / 1000 / 1440
```

Set prescaler (PSC) to `999` and auto-reload (ARR) to `1439`.

### Step 2: MPU6050 Driver Files

Port these files to your project:

```
MPU6050.c      // Sensor initialization and data reading
MPU6050.h      // Function declarations
MPU6050_Reg.h  // Register address definitions
MyI2C.c        // Software I2C implementation
MyI2C.h        // I2C function declarations
```

### Step 3: Pin Configuration

The MPU6050 connects via I2C on **PB8** (SCL) and **PB9** (SDA). Update `MyI2C.c` accordingly.

### Step 4: Sampling Rate Configuration

Configure the sample rate divider register:

```c
// Sample Rate = 1kHz / (1 + SMPLRT_DIV)
// For 50Hz: SMPLRT_DIV = 19 (0x13)
MPU6050_WriteReg(MPU6050_SMPLRT_DIV, 0x13);
```

> **Tip**: Enable the Digital Low-Pass Filter (DLPF) to reduce noise. With DLPF enabled, the base rate is 1kHz.

### Step 5: Range Configuration

```c
// Gyroscope: ±2000°/s (maximum range for fast rotations)
MPU6050_WriteReg(MPU6050_GYRO_CONFIG, 0x18);

// Accelerometer: ±2g (higher resolution for gravity measurement)
MPU6050_WriteReg(MPU6050_ACCEL_CONFIG, 0x00);
```

### Step 6: Unit Conversion

Convert raw 16-bit values to physical units:

```c
// Accelerometer: ±2g range → 16384 LSB/g
float accel_ms2 = (float)raw_accel / 16384.0f * 9.81f;

// Gyroscope: ±2000°/s range → 16.4 LSB/(°/s)
float gyro_rads = (float)raw_gyro / 16.4f * (3.14159f / 180.0f);
```

> **Note**: Use `float` type for converted values to maintain precision.

### Resolution vs Accuracy

These are distinct concepts:

- **Resolution**: The smallest detectable change (determined by ADC bits and range)
- **Accuracy**: How close measurements are to true values (limited by sensor noise)

The MPU6050 has significant noise, so higher resolution doesn't guarantee better accuracy. However, using ±2g range still helps because it better characterizes the noise for subsequent filtering.

---

*Next: [3. Kalman Filter for Sensor Fusion →](./3.kalman-filter)*